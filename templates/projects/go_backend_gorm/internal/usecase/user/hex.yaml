# Configuration used to generate this use case file
# Generated by: gohex engine
# Template: internal/usecase/{{DOMAIN}}/usecase.go.tmpl
# Domain: user
# Entity: User

layer: "use_case"
domain: "user"
entity: "User"

# Use case configuration that produced this file
use_case:
  name: "UserUseCase"
  interface_name: "IUserUseCase"
  description: "User business logic layer"
  package: "user"
  
  # Dependencies injected into use case
  dependencies:
    - name: "userRepo"
      type: "repoPkg.IUserRepository"
      source: "repositories_container"
      field_name: "User"
      description: "User repository for data access"
      
    - name: "logger"
      type: "*utils.Logger"
      injection: "do.MustInvoke[*utils.Logger](injector)"
      description: "Logger for debugging and monitoring"

  # Standard business logic methods generated automatically
  standard_methods:
    - name: "Create"
      description: "Create creates a new user"
      parameters:
        - name: "ctx"
          type: "context.Context"
        - name: "user"
          type: "*entityPkg.User"
      returns: ["error"]
      operation: "create"
      delegates_to: "userRepo.Create"
      business_logic: "pass_through"  # Could be "validation", "transformation", etc.
      
    - name: "GetByID"
      description: "GetByID retrieves a user by ID"
      parameters:
        - name: "ctx"
          type: "context.Context"
        - name: "id"
          type: "uuid.UUID"
      returns: ["*entityPkg.User", "error"]
      operation: "read_by_id"
      delegates_to: "userRepo.GetByID"
      business_logic: "pass_through"
      
    - name: "List"
      description: "List retrieves a list of users with optional filtering"
      parameters:
        - name: "ctx"
          type: "context.Context"
        - name: "filters"
          type: "map[string]interface{}"
        - name: "limit"
          type: "int"
        - name: "offset"
          type: "int"
      returns: ["[]*entityPkg.User", "error"]
      operation: "list"
      delegates_to: "userRepo.List"
      business_logic: "pass_through"
      
    - name: "Update"
      description: "Update updates an existing user"
      parameters:
        - name: "ctx"
          type: "context.Context"
        - name: "user"
          type: "*entityPkg.User"
      returns: ["error"]
      operation: "update"
      delegates_to: "userRepo.Update"
      business_logic: "pass_through"
      
    - name: "Delete"
      description: "Delete deletes a user by ID"
      parameters:
        - name: "ctx"
          type: "context.Context"
        - name: "id"
          type: "uuid.UUID"
      returns: ["error"]
      operation: "delete"
      delegates_to: "userRepo.Delete"
      business_logic: "pass_through"

  # Custom business logic methods would be added here
  # Example of what could be configured:
  # custom_methods:
  #   - name: "AuthenticateUser"
  #     description: "Authenticate user with email and password"
  #     parameters:
  #       - name: "ctx"
  #         type: "context.Context"
  #       - name: "email"
  #         type: "string"
  #       - name: "password"
  #         type: "string"
  #     returns: ["*entityPkg.User", "error"]
  #     business_logic: "custom"
  #     placeholder: true

# Dependency resolution configuration
dependency_resolution:
  container_type: "*repository.Repositories"
  field_lookup: "repository.GetField"
  error_handling: "type_assertion_check"
  reflection_based: true

# Business logic configuration
business_logic:
  validation_layer: false    # Could be enabled for input validation
  transformation_layer: false  # Could be enabled for data transformation
  authorization_layer: false   # Could be enabled for access control
  audit_layer: false         # Could be enabled for audit logging
  
# Logging configuration
logging:
  enabled: true
  level: "debug"
  method_entry: true
  method_parameters: true

# Template variables used during generation
template_vars:
  domain: "user"
  domain_snake: "user"
  entity: "User"
  entity_snake: "user"
  entities: "Users"
  entities_snake: "users"
  module: "go_backend_gorm"

# Generation metadata
generation:
  template_file: "internal/usecase/{{DOMAIN}}/usecase.go.tmpl"
  output_file: "internal/usecase/user/user_usecase.go"
  generated_at: "2024-12-20T10:30:00Z"
  generator_version: "1.0.0"
  preserve_custom_code: true

# Custom code regions (for code preservation)
custom_regions:
  - name: "custom_business_logic"
    marker: "// Add custom business logic here"
    description: "Add domain-specific business rules and validation"
    location: "after_standard_methods"
    
  - name: "custom_validation"
    marker: "// Add custom validation here"
    description: "Add business rule validation before repository calls"
    location: "within_methods"
