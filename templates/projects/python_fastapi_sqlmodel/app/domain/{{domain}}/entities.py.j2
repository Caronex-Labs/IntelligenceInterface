"""{{domain.name|title}} domain entities - Generated from Co-located Template.

This module contains SQLModel entities for the {{domain.name}} domain following
hexagonal architecture principles with co-location pattern implementation.

Generated from:
- domain.yaml: Base entity configuration and mixins
- entities.yaml: Entity-specific field definitions and relationships
- entities.py.j2: This Jinja2 template

Co-location Architecture:
- Templates, configurations, and generated files in same directory
- Hierarchical configuration merging for complete context
- @pyhex preservation markers for custom business logic
"""

# Standard library imports
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional, List, Dict, Any{% if template_context.features.enable_audit_log %}, Union{% endif %}
{% if template_context.features.enable_caching %}, TYPE_CHECKING{% endif %}

# Third-party imports
from sqlmodel import SQLModel, Field, Relationship{% if template_context.features.enable_full_text_search %}, text{% endif %}
from pydantic import EmailStr, validator, root_validator{% if template_context.features.enable_audit_log %}, Field as PydanticField{% endif %}
{% if template_context.features.enable_soft_delete %}from sqlalchemy import Boolean, DateTime{% endif %}
{% set json_import_needed = false %}
{% for entity in entities %}
{% if entity.fields %}
{% for field in entity.fields %}
{% if field.type == "json" %}{% set json_import_needed = true %}{% endif %}
{% endfor %}
{% endif %}
{% endfor %}
{% if json_import_needed %}from sqlalchemy.dialects.postgresql import JSON{% endif %}

# @pyhex:begin:custom_imports
# Add custom imports here - preserved during regeneration
# @pyhex:end:custom_imports

{% if entity.mixins %}
# Base mixins from domain configuration
{% for mixin in entity.mixins %}
{% if mixin.enabled %}
class {{mixin.name}}:
    """{{mixin.description}}"""
    {% if mixin.name == "UUIDMixin" %}
    id: Optional[UUID] = Field(
        default_factory={{primary_key.default_factory}},
        primary_key=True,
        description="{{primary_key.description}}"
    )
    {% elif mixin.name == "TimestampMixin" %}
    {% for field in mixin.fields %}
    {{field}}: datetime = Field(
        default_factory={{timestamps[field].default_factory}},
        description="{{timestamps[field].description}}"{% if timestamps[field].index %},
        sa_column_kwargs={"index": True}{% endif %}
    )
    {% endfor %}
    {% elif mixin.name == "SoftDeleteMixin" and template_context.features.enable_soft_delete %}
    {% for field in mixin.fields %}
    {% if field == "deleted_at" %}
    {{field}}: Optional[datetime] = Field(
        default={{timestamps.deleted_at.default}},
        description="{{timestamps.deleted_at.description}}"
    )
    {% elif field == "is_deleted" %}
    {{field}}: bool = Field(
        default=False,
        description="Soft delete flag"
    )
    {% endif %}
    {% endfor %}
    {% endif %}

{% endif %}
{% endfor %}
{% endif %}

# @pyhex:begin:custom_mixins
# Add custom mixin classes here - preserved during regeneration
# @pyhex:end:custom_mixins

{% for entity in entities %}
# {{entity.description}}
class {{entity.name}}Base(SQLModel{% for mixin in entity.mixins %}, {{mixin}}{% endfor %}):
    """Base model for {{entity.name}} with shared fields and validation.
    
    This base class contains common fields and validation logic that will be
    inherited by both the table model and API schemas.
    
    Attributes:
    {% for field in entity.fields %}
        {{field.name}}: {{field.description}}
    {% endfor %}
    """
    
    # Business fields from entities.yaml configuration
    {% for field in entity.fields %}
    {% set field_type = field_types[field.type] if field.type in field_types else {"python_type": field.type, "sqlmodel_type": field.type} %}
    {{field.name}}: {% if field.required %}{{field_type.python_type}}{% else %}Optional[{{field_type.python_type}}]{% endif %} = Field(
        {% if field.default is defined %}default={{field.default}},{% endif %}
        {% if field.default_factory is defined %}default_factory={{field.default_factory}},{% endif %}
        description="{{field.description}}"{% if field.example is defined %},
        example={{field.example}}{% endif %}{% if field.unique %},
        unique=True{% endif %}{% if field.index %},
        sa_column_kwargs={"index": True}{% endif %}{% if field.validation and field.validation.min_length %},
        min_length={{field.validation.min_length}}{% endif %}{% if field.validation and field.validation.max_length %},
        max_length={{field.validation.max_length}}{% endif %}
    )
    {% endfor %}

    # @pyhex:begin:custom_fields_{{entity.name|lower}}
    # Add custom fields for {{entity.name}} here - preserved during regeneration
    # @pyhex:end:custom_fields_{{entity.name|lower}}

    class Config:
        """Pydantic configuration for {{entity.name}}."""
        {% if integration.pydantic.validate_assignment %}validate_assignment = True{% endif %}
        {% if integration.pydantic.use_enum_values %}use_enum_values = True{% endif %}
        {% if integration.pydantic.allow_population_by_field_name %}allow_population_by_field_name = True{% endif %}
        {% if generation.style.use_type_hints %}arbitrary_types_allowed = True{% endif %}
        
        # @pyhex:begin:custom_config_{{entity.name|lower}}
        # Add custom Pydantic configuration here - preserved during regeneration
        # @pyhex:end:custom_config_{{entity.name|lower}}

    {% for field in entity.fields %}
    {% if field.validation %}
    @validator('{{field.name}}')
    def validate_{{field.name}}(cls, v):
        """Validate {{field.name}} field with business rules.
        
        Args:
            v: The field value to validate
            
        Returns:
            The validated value
            
        Raises:
            ValueError: If validation fails
        """
        {% if field.validation.min_length %}
        if isinstance(v, str) and len(v) < {{field.validation.min_length}}:
            raise ValueError('{{field.name}} must be at least {{field.validation.min_length}} characters')
        {% endif %}
        {% if field.validation.max_length %}
        if isinstance(v, str) and len(v) > {{field.validation.max_length}}:
            raise ValueError('{{field.name}} must be no more than {{field.validation.max_length}} characters')
        {% endif %}
        {% if field.validation.choices %}
        if v not in {{field.validation.choices}}:
            raise ValueError('{{field.name}} must be one of: {{field.validation.choices|join(", ")}}')
        {% endif %}
        {% if field.validation.pattern %}
        import re
        if v and not re.match(r'{{field.validation.pattern}}', v):
            raise ValueError('{{field.name}} format is invalid')
        {% endif %}
        
        # @pyhex:begin:custom_validation_{{field.name}}
        # Add custom validation logic for {{field.name}} here - preserved during regeneration
        # @pyhex:end:custom_validation_{{field.name}}
        
        return v
    {% endif %}
    {% endfor %}

    {% if entity.validation and entity.validation.business_rules %}
    @root_validator
    def validate_business_rules(cls, values):
        """Validate business rules for {{entity.name}}.
        
        Args:
            values: Dictionary of all field values
            
        Returns:
            Validated values dictionary
            
        Raises:
            ValueError: If business rule validation fails
        """
        # Generated business rule validations
        {% for rule in entity.validation.business_rules %}
        {% if rule.type == "custom_validator" %}
        # {{rule.description}}
        if hasattr(cls, '{{rule.method}}'):
            cls.{{rule.method}}(values)
        {% endif %}
        {% endfor %}
        
        # @pyhex:begin:custom_business_rules_{{entity.name|lower}}
        # Add custom business rule validation here - preserved during regeneration
        # @pyhex:end:custom_business_rules_{{entity.name|lower}}
        
        return values
    {% endif %}

    {% if entity.generation and entity.generation.methods %}
    # Generated utility methods
    {% for method in entity.generation.methods %}
    def {{method.name}}(self) -> {{method.return_type}}:
        """{{method.description}}"""
        {% if method.implementation %}
        {{method.implementation}}
        {% else %}
        # @pyhex:begin:method_{{method.name}}_{{entity.name|lower}}
        # Implement {{method.name}} method here - preserved during regeneration
        pass
        # @pyhex:end:method_{{method.name}}_{{entity.name|lower}}
        {% endif %}
    {% endfor %}
    {% endif %}

    # @pyhex:begin:custom_methods_{{entity.name|lower}}
    # Add custom methods for {{entity.name}} here - preserved during regeneration
    # @pyhex:end:custom_methods_{{entity.name|lower}}


class {{entity.name}}({{entity.name}}Base, table=True):
    """SQLModel table definition for {{entity.name}}.
    
    This class represents the database table for {{entity.name}} entities.
    It inherits all fields and validation from {{entity.name}}Base and adds
    table-specific configuration and relationships.
    """
    
    __tablename__ = "{{entity.table_name}}"
    
    {% if entity.database and entity.database.table_args %}
    {% if entity.database.table_args.indexes or entity.database.table_args.constraints %}
    __table_args__ = (
        {% if entity.database.table_args.indexes %}
        # Indexes from entities.yaml configuration
        {% for index in entity.database.table_args.indexes %}
        {% if index.unique %}
        {"postgresql_unique": True, "name": "{{index.name}}"},
        {% else %}
        {"name": "{{index.name}}"},
        {% endif %}
        {% endfor %}
        {% endif %}
        {% if entity.database.table_args.constraints %}
        # Constraints from entities.yaml configuration  
        {% for constraint in entity.database.table_args.constraints %}
        {% if constraint.type == "check" %}
        {"postgresql_check": "{{constraint.condition}}", "name": "{{constraint.name}}"},
        {% endif %}
        {% endfor %}
        {% endif %}
    )
    {% endif %}
    {% endif %}

    # Relationships from entities.yaml configuration
    {% if entity.relationships %}
    {% for relationship in entity.relationships %}
    {{relationship.name}}: {% if relationship.type == "one_to_many" %}List["{{relationship.target_entity}}"]{% elif relationship.type == "one_to_one" %}Optional["{{relationship.target_entity}}"]{% elif relationship.type == "many_to_many" %}List["{{relationship.target_entity}}"]{% elif relationship.type == "many_to_one" %}"{{relationship.target_entity}}"{% endif %} = Relationship(
        {% if relationship.back_populates %}back_populates="{{relationship.back_populates}}"{% endif %}{% if relationship.cascade %},
        sa_relationship_kwargs={"cascade": "{{relationship.cascade}}"}{% endif %}{% if relationship.lazy %},
        sa_relationship_kwargs={"lazy": "{{relationship.lazy}}"}{% endif %}{% if relationship.uselist is defined %},
        sa_relationship_kwargs={"uselist": {{relationship.uselist|lower}}}{% endif %}
    )
    {% endfor %}
    {% endif %}

    # @pyhex:begin:custom_relationships_{{entity.name|lower}}
    # Add custom relationships for {{entity.name}} here - preserved during regeneration
    # @pyhex:end:custom_relationships_{{entity.name|lower}}

    def __repr__(self) -> str:
        """String representation of {{entity.name}}."""
        {% if entity.fields %}
        {% set display_field = entity.fields[0] %}
        return f"{{entity.name}}(id={self.id}, {{display_field.name}}={self.{{display_field.name}}})"
        {% else %}
        return f"{{entity.name}}(id={self.id})"
        {% endif %}

    # @pyhex:begin:custom_table_methods_{{entity.name|lower}}
    # Add custom table-specific methods here - preserved during regeneration
    # @pyhex:end:custom_table_methods_{{entity.name|lower}}


# API Schema Models for FastAPI integration
class {{entity.name}}Create({{entity.name}}Base):
    """Request schema for creating {{entity.name}}.
    
    Excludes auto-generated fields like id, timestamps.
    Used for POST requests in FastAPI endpoints.
    """
    pass


class {{entity.name}}Update(SQLModel):
    """Request schema for updating {{entity.name}}.
    
    All fields are optional to support partial updates.
    Used for PUT/PATCH requests in FastAPI endpoints.
    """
    {% for field in entity.fields %}
    {% if not field.name in ['id', 'created_at', 'updated_at'] %}
    {% set field_type = field_types[field.type] if field.type in field_types else {"python_type": field.type} %}
    {{field.name}}: Optional[{{field_type.python_type}}] = Field(
        default=None,
        description="{{field.description}}"
    )
    {% endif %}
    {% endfor %}

    # @pyhex:begin:custom_update_fields_{{entity.name|lower}}
    # Add custom update fields here - preserved during regeneration
    # @pyhex:end:custom_update_fields_{{entity.name|lower}}


class {{entity.name}}Response({{entity.name}}Base):
    """Response schema for {{entity.name}}.
    
    Includes all fields including auto-generated ones.
    Used for API responses in FastAPI endpoints.
    """
    id: UUID
    created_at: datetime
    updated_at: datetime
    {% if template_context.features.enable_soft_delete %}
    {% if entity.mixins and "SoftDeleteMixin" in entity.mixins %}
    deleted_at: Optional[datetime] = None
    is_deleted: bool = False
    {% endif %}
    {% endif %}

    class Config({{entity.name}}Base.Config):
        """Response model configuration."""
        {% if integration.fastapi.include_examples %}
        schema_extra = {
            "example": {
                {% for field in entity.fields %}
                {% if field.example is defined %}
                "{{field.name}}": {{field.example}},
                {% endif %}
                {% endfor %}
                "id": "{{primary_key.default_factory}}()",
                "created_at": "2023-01-01T00:00:00Z",
                "updated_at": "2023-01-01T00:00:00Z"
            }
        }
        {% endif %}

    # @pyhex:begin:custom_response_methods_{{entity.name|lower}}
    # Add custom response methods here - preserved during regeneration
    # @pyhex:end:custom_response_methods_{{entity.name|lower}}


{% endfor %}

# @pyhex:begin:custom_entities
# Add custom entity classes here - preserved during regeneration
# @pyhex:end:custom_entities


# Domain service functions
{% for entity in entities %}
def create_{{entity.name|lower}}_from_dict(data: Dict[str, Any]) -> {{entity.name}}:
    """Create {{entity.name}} instance from dictionary.
    
    Args:
        data: Dictionary containing {{entity.name}} field values
        
    Returns:
        New {{entity.name}} instance
        
    Raises:
        ValueError: If required fields are missing or invalid
    """
    # @pyhex:begin:custom_creation_logic_{{entity.name|lower}}
    # Add custom creation logic here - preserved during regeneration
    # @pyhex:end:custom_creation_logic_{{entity.name|lower}}
    
    return {{entity.name}}(**data)


def validate_{{entity.name|lower}}_business_rules(entity: {{entity.name}}) -> List[str]:
    """Validate business rules for {{entity.name}}.
    
    Args:
        entity: {{entity.name}} instance to validate
        
    Returns:
        List of validation error messages (empty if valid)
    """
    errors = []
    
    {% if entity.validation and entity.validation.business_rules %}
    # Generated business rule validations
    {% for rule in entity.validation.business_rules %}
    {% if rule.type == "unique_constraint" %}
    # {{rule.description}}
    # Note: Actual uniqueness validation should be done at database/repository level
    {% elif rule.type == "regex_validator" %}
    # {{rule.description}}
    import re
    {% for field in rule.fields %}
    if hasattr(entity, '{{field}}') and entity.{{field}}:
        if not re.match(r'{{rule.pattern}}', entity.{{field}}):
            errors.append("{{field}} format is invalid")
    {% endfor %}
    {% endif %}
    {% endfor %}
    {% endif %}
    
    # @pyhex:begin:custom_business_validation_{{entity.name|lower}}
    # Add custom business rule validation here - preserved during regeneration
    # @pyhex:end:custom_business_validation_{{entity.name|lower}}
    
    return errors


{% endfor %}

# @pyhex:begin:custom_domain_functions
# Add custom domain service functions here - preserved during regeneration
# @pyhex:end:custom_domain_functions


# Export all entity classes for easy importing
__all__ = [
    {% for entity in entities %}
    "{{entity.name}}",
    "{{entity.name}}Base", 
    "{{entity.name}}Create",
    "{{entity.name}}Update",
    "{{entity.name}}Response",
    {% endfor %}
    # Custom exports
    # @pyhex:begin:custom_exports
    # Add custom exports here - preserved during regeneration
    # @pyhex:end:custom_exports
]